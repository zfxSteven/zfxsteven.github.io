<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nlp服务部署手册（LINUX）</title>
      <link href="/2020/03/23/nlp-fu-wu-bu-shu-shou-ce/"/>
      <url>/2020/03/23/nlp-fu-wu-bu-shu-shou-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="nlp服务部署手册（LINUX）"><a href="#nlp服务部署手册（LINUX）" class="headerlink" title="nlp服务部署手册（LINUX）"></a>nlp服务部署手册（LINUX）</h1><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><ol><li>安装Centos7-base</li><li>无网络安装docker</li><li>导入镜像、设置运行环境</li><li>启动NLP模型容器及服务</li><li>启动缓存、测试及指标管理服务</li></ol><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-安装Centos7-base"><a href="#1-安装Centos7-base" class="headerlink" title="1. 安装Centos7-base"></a>1. 安装Centos7-base</h3><blockquote><p><a href="https://pan.baidu.com/s/1A6-xTDxOLxlL2IRGMWhlvw" target="_blank" rel="noopener">百度云盘 centos7镜像链接</a><br>提取码：66if</p></blockquote><p>选择centos7的一个稳定版本，安装的时候注意的问题：</p><ol><li>语言选择英文：<br><img src="language_setting.png" alt="img 服务器语言选择"></li><li>选择最小安装<br><img src="install_setting.png" alt="img 服务器安装配置选择"></li><li>硬盘空间分配不要使用默认配置，除了基础的启动和swap，将剩余所有空间挂载到根目录下<br><img src="disk_setting.png" alt="img 硬盘分配"><br><img src="disk_setting_2.png" alt="img 选择自己分配"><br><img src="disk_setting_3.png" alt="img 以100G的硬盘为例">  </li></ol><h3 id="2-无网络安装docker"><a href="#2-无网络安装docker" class="headerlink" title="2. 无网络安装docker"></a>2. 无网络安装docker</h3><p>服务所使用的docker文件为docker-19.03.5.tgz</p><blockquote><p>文件链接<br><a href=" docker-18.09.3.tgz" target="_blank">docker-19.03.5.tgz</a>  </p></blockquote><ol><li><p>解压  </p><pre class=" language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">tar</span> zxvf docker-19.03.5.tgz </code></pre></li><li><p>解压之后生成一个docker文件， 将docker文件中的内的文件复制到/usr/bin目录下 </p><pre class=" language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">cp</span> docker/* /usr/bin/</code></pre></li><li><p>拷贝过去的文件需要执行权限 </p><pre class=" language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/bin/docker* <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/bin/containerd* <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/bin/ctr <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/bin/runc</code></pre></li><li><p>补充服务文件，并添加权限  </p><pre class=" language-bash"><code class="language-bash"> vim /etc/systemd/system/docker.service <span class="token function">chmod</span> +w docker.service <span class="token function">chmod</span>   +x   /etc/systemd/system/docker.service</code></pre><p> 写入的内容  </p><pre class=" language-ini"><code class="language-ini"><span class="token selector"> [Unit]</span><span class="token constant"> Description</span><span class="token attr-value"><span class="token punctuation">=</span>Docker Application Container Engine</span><span class="token constant"> Documentation</span><span class="token attr-value"><span class="token punctuation">=</span>https://docs.docker.com</span><span class="token constant"> After</span><span class="token attr-value"><span class="token punctuation">=</span>network-online.target firewalld.service</span><span class="token constant"> Wants</span><span class="token attr-value"><span class="token punctuation">=</span>network-online.target</span><span class="token selector"> [Service]</span><span class="token constant"> Type</span><span class="token attr-value"><span class="token punctuation">=</span>notify</span> # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker<span class="token constant"> ExecStart</span><span class="token attr-value"><span class="token punctuation">=</span>/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><span class="token constant"> ExecReload</span><span class="token attr-value"><span class="token punctuation">=</span>/bin/kill -s HUP $MAINPID</span> # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting.<span class="token constant"> LimitNOFILE</span><span class="token attr-value"><span class="token punctuation">=</span>infinity</span><span class="token constant"> LimitNPROC</span><span class="token attr-value"><span class="token punctuation">=</span>infinity</span><span class="token constant"> LimitCORE</span><span class="token attr-value"><span class="token punctuation">=</span>infinity</span> # Uncomment TasksMax if your systemd version supports it. # Only systemd 226 and above support this version.<span class="token constant"> #TasksMax</span><span class="token attr-value"><span class="token punctuation">=</span>infinity</span><span class="token constant"> TimeoutStartSec</span><span class="token attr-value"><span class="token punctuation">=</span>0</span> # set delegate yes so that systemd does not reset the cgroups of docker containers<span class="token constant"> Delegate</span><span class="token attr-value"><span class="token punctuation">=</span>yes</span> # kill only the docker process, not all processes in the cgroup<span class="token constant"> KillMode</span><span class="token attr-value"><span class="token punctuation">=</span>process</span> # restart the docker process if it exits prematurely<span class="token constant"> Restart</span><span class="token attr-value"><span class="token punctuation">=</span>on-failure</span><span class="token constant"> StartLimitBurst</span><span class="token attr-value"><span class="token punctuation">=</span>3</span><span class="token constant"> StartLimitInterval</span><span class="token attr-value"><span class="token punctuation">=</span>60s</span><span class="token selector"> [Install]</span><span class="token constant"> WantedBy</span><span class="token attr-value"><span class="token punctuation">=</span>multi-user.target</span></code></pre></li><li><p>添加服务到系统，并启动</p><pre class=" language-bash"><code class="language-bash"> systemctl   daemon-reload systemctl   start     docker systemctl   <span class="token function">enable</span>    docker.service systemctl   status    docker <span class="token function">sudo</span>  docker  version</code></pre></li><li><p>docker 解决容器内访问宿主机“No route to host”的问题,修复方式请顺序运行以下命令：  </p><pre class=" language-bash"><code class="language-bash"> nmcli connection modify docker0 connection.zone trusted systemctl stop NetworkManager.service firewall-cmd --permanent --zone<span class="token operator">=</span>trusted --change-interface<span class="token operator">=</span>docker0 systemctl start NetworkManager.service nmcli connection modify docker0 connection.zone trusted systemctl restart docker.service</code></pre></li><li><p>docker服务安装好以后，可能会存在不生效的情况，<br>有一种导致这种情况的原因是某些系统配置没有加载，可以尝试重启服务器（重启之前联系网管看一下）</p></li></ol><h3 id="3-导入镜像、设置运行环境"><a href="#3-导入镜像、设置运行环境" class="headerlink" title="3. 导入镜像、设置运行环境"></a>3. 导入镜像、设置运行环境</h3><blockquote><p>NLP整体服务有两个镜像：  </p><ol><li>一个是深度学习的模型推理镜像  </li><li>一个是缓存和接口服务   </li></ol></blockquote><blockquote><p>文件网盘地址<br><a href="https://pan.baidu.com/s/1QoG8C_6pQ8-Sud2V9_aQDg" target="_blank" rel="noopener">推理模型镜像文件</a><br>提取码：mqzk<br><a href="https://pan.baidu.com/s/1HtT1Yg4t5vahNYdtNXh1sg" target="_blank" rel="noopener">缓存接口镜像文件</a><br>提取码：0xa8  </p></blockquote><p>上传文件于服务器，然后导入，导入命令：</p><pre class=" language-bash"><code class="language-bash">docker image load -i 镜像文件路径</code></pre><h3 id="4-启动NLP模型容器及服务"><a href="#4-启动NLP模型容器及服务" class="headerlink" title="4.启动NLP模型容器及服务"></a>4.启动NLP模型容器及服务</h3><ol><li><p>设置端口等，启动容器</p><pre class=" language-bash"><code class="language-bash">SSH_PORT<span class="token operator">=</span>6522BT_PANEL<span class="token operator">=</span>6588BT_PANEL_PORT<span class="token operator">=</span>6589NRE_SERVICE_PORT<span class="token operator">=</span>6500YG_SERVICE_PORT<span class="token operator">=</span>6501GRAPH_DEBUG_API_PORT<span class="token operator">=</span>6502GRAPH_DEBUG_WEB_PORT<span class="token operator">=</span>6503OFR_API_PORT<span class="token operator">=</span>6504OFR_WEB_PORT<span class="token operator">=</span>6505docker run -idt --name nlp_server_simple -p <span class="token variable">$SSH_PORT</span>:22 -p <span class="token variable">$BT_PANEL</span>:8888 -p <span class="token variable">$BT_PANEL_PORT</span>:888 -p <span class="token variable">$NRE_SERVICE_PORT</span>:5000 -p <span class="token variable">$YG_SERVICE_PORT</span>:5001 -p <span class="token variable">$GRAPH_DEBUG_API_PORT</span>:5002 -p <span class="token variable">$GRAPH_DEBUG_WEB_PORT</span>:5003 -p <span class="token variable">$OFR_API_PORT</span>:5004 -p <span class="token variable">$OFR_WEB_PORT</span>:5005 nlp_server_simple:v0.2 /bin/bash</code></pre></li><li><p>进入容器</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it nlp_server_simple /bin/bash</code></pre></li><li><p>依次启动服务</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 nginx</span><span class="token function">service</span> nginx restart<span class="token comment" spellcheck="true"># 启动 NER NRE</span><span class="token comment" spellcheck="true"># 1. 加载python环境</span><span class="token function">source</span> /home/nlp/nlp_service_v1.1_model_date_20180815_v2/venv/bin/activate<span class="token comment" spellcheck="true"># 2. 结点1</span><span class="token function">cd</span> /home/nlp/nlp_service_v1.1_model_date_20180815_v2uwsgi -c uwsgi_socks.ini<span class="token comment" spellcheck="true"># 3. 结点2</span><span class="token function">cd</span> /home/nlp/nlp_service_v1.1_model_date_20180815_v2_bakuwsgi -c uwsgi_socks.ini<span class="token comment" spellcheck="true"># 2. 启动超范围服务</span><span class="token function">source</span> /home/nlp/nlp_service_v1.1_model_date_20180815_v2/venv/bin/activate<span class="token function">cd</span> /home/cfw/server/uwsgi -c uwsgi.ini </code></pre></li><li><p>测试浏览器打开  </p><ol><li>ip:6500  </li><li>ip:6501<br><img src="nre_service_success.png" alt="img 成功结果" title="成功结果"></li></ol></li></ol><h3 id="5-启动缓存、测试及指标管理服务"><a href="#5-启动缓存、测试及指标管理服务" class="headerlink" title="5. 启动缓存、测试及指标管理服务"></a>5. 启动缓存、测试及指标管理服务</h3><ol><li>启动容器<pre class=" language-bash"><code class="language-bash"> docker run --name<span class="token operator">=</span>gqlserver -dit --privileged<span class="token operator">=</span>true -p 9180:9180 -p 5432:5432 gqlserver:2.0  /usr/sbin/init</code></pre></li><li>进入容器<pre class=" language-bash"><code class="language-bash"> docker <span class="token function">exec</span> -it gqlserver <span class="token function">bash</span></code></pre></li><li>修改配置文件<pre class=" language-bash"><code class="language-bash">vim /opt/apache-tomcat-9.0.27/conf/application.properties</code></pre>修改的部分：<pre class=" language-ini"><code class="language-ini"><span class="token constant">spring.datasource.master.driver-class-name</span><span class="token attr-value"><span class="token punctuation">=</span>org.postgresql.Driver</span><span class="token constant"> spring.datasource.master.jdbc-url</span><span class="token attr-value"><span class="token punctuation">=</span>jdbc:postgresql://[服务器IP]:5432/nlp</span><span class="token constant"> spring.datasource.master.username</span><span class="token attr-value"><span class="token punctuation">=</span>nlp</span><span class="token constant"> spring.datasource.master.password</span><span class="token attr-value"><span class="token punctuation">=</span>nlp</span></code></pre></li><li>启动tomcat<pre class=" language-bash"><code class="language-bash"> /opt/apache-tomcat-9.0.27/bin/startup.sh</code></pre></li><li>在浏览器上输入：[服务器IP]:9180/nlp<ol><li>院感默认用户：yg 密码：1</li><li>点击系统参数，修改对应服务的IP地址和端口</li><li>点击GQL查询， 输入一段病历<br>NLP解析效果：<br><img src="nlp_example_1.png" alt="img 成功结果1" title="成功结果1"><br><img src="nlp_example_2.png" alt="img 成功结果2" title="成功结果2">  </li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归</title>
      <link href="/2020/03/18/luo-ji-hui-gui/"/>
      <url>/2020/03/18/luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为自己的模型打打分</title>
      <link href="/2020/03/11/wei-zi-ji-de-mo-xing-da-da-fen/"/>
      <url>/2020/03/11/wei-zi-ji-de-mo-xing-da-da-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="为自己的模型打打分"><a href="#为自己的模型打打分" class="headerlink" title="为自己的模型打打分"></a>为自己的模型打打分</h1><h2 id="好不好"><a href="#好不好" class="headerlink" title="好不好"></a>好不好</h2><p>怎么才能说一个模型好不好，这个说法过于笼统，过于主观。<br>那就具体一点，先来定性  </p><blockquote><p>定性：<br>这个模型能不能满足我们的任务目标要求?（是/不是）  </p></blockquote><p>这个问题就有是与不是这两个选项，不管怎么评估模型的效果，总有一个答案：是 或者 不是。<br>理想很丰满，现实很骨感。<br>这样的回答过于绝对了，非黑即白。<br>通常模型分类结果不会100%准确，拟合结果不会100%相等。<br>一个预测模型预测100个分类，错了6个，这个模型到底能不能用？<br>这些都不是靠感觉，靠是与不是能简单回答的问题了。<br>所以，要定量。</p><blockquote><p>定量<br>准确度、召回率、F1 等等</p></blockquote><h2 id="行不行"><a href="#行不行" class="headerlink" title="行不行"></a>行不行</h2><p><code>模型评价与你任务目标是绑在一起的</code></p><p>可能要考虑的几个方面  </p><ol><li>准不准:<br>模型能否将样本正确的分类。有很多县城的评价指标，precision、recall、F1_score等等，且能在任务中找出一定的实际意义<br>我自己简单实现了一个python的工具包，<a href="1">math_tools.py</a>（其实是针对ROC去弄的）</li><li>稳不稳：<br>收集所有的数据供模型学习，这既是一个可能无穷成本，且违背机器学习本意的一个事情。<br>在少量的样本上学习，在新样本上预测。对于没见过的新样本，怎样不预测错误，或者太偏离实际结果。<br>这就是模型的稳定性，有的也说鲁棒性。<br>典型反例：<a href="2">龙格现象</a></li></ol><p><img src="/images/20180406180222421.png" alt="img 龙格现象" title="龙格函数">  </p><p>最终在实际任务上行不行，还是和设定任务时制定的标准说了算：模型评价与你任务目标是绑在一起的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="https://github.com/zfxSteven/model-result-eval-metrics/blob/master/math_tools.py" target="_blank" rel="noopener">https://github.com/zfxSteven/model-result-eval-metrics/blob/master/math_tools.py</a><br>[2] <a href="https://blog.csdn.net/qq_39521554/article/details/79835492" target="_blank" rel="noopener">https://blog.csdn.net/qq_39521554/article/details/79835492</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Hello World!</title>
      <link href="/2020/03/11/hello-world-0/"/>
      <url>/2020/03/11/hello-world-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>这是独属于程序员的浪漫</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/11/hello-world/"/>
      <url>/2020/03/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
